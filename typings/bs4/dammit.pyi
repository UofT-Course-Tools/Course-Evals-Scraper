"""
This type stub file was generated by pyright.
"""

import re
from typing import Any, Optional

"""Beautiful Soup bonus library: Unicode, Dammit

This library converts a bytestream to Unicode through any means
necessary. It is heavily based on code from Mark Pilgrim's Universal
Feed Parser. It works best on XML and HTML, but it does not rewrite the
XML or HTML to reflect a new encoding; that's the tree builder's job.
"""
__license__ = "MIT"
chardet_type = None
xml_encoding_re = re.compile('^<\\?.*encoding=[\'"](.*?)[\'"].*\\?>'.encode(), re.I)
html_meta_re = re.compile('<\\s*meta[^>]+charset\\s*=\\s*["\']?([^>]*?)[ /;\'">]'.encode(), re.I)
class EntitySubstitution(object):
    """Substitute XML or HTML entities for the corresponding characters."""
    def _populate_class_variables():
        ...
    
    CHARACTER_TO_XML_ENTITY = ...
    BARE_AMPERSAND_OR_BRACKET = ...
    AMPERSAND_OR_BRACKET = ...
    @classmethod
    def _substitute_html_entity(cls, matchobj):
        ...
    
    @classmethod
    def _substitute_xml_entity(cls, matchobj):
        """Used with a regular expression to substitute the
        appropriate XML entity for an XML special character."""
        ...
    
    @classmethod
    def quoted_attribute_value(self, value):
        """Make a value into a quoted XML attribute, possibly escaping it.

         Most strings will be quoted using double quotes.

          Bob's Bar -> "Bob's Bar"

         If a string contains double quotes, it will be quoted using
         single quotes.

          Welcome to "my bar" -> 'Welcome to "my bar"'

         If a string contains both single and double quotes, the
         double quotes will be escaped, and the string will be quoted
         using double quotes.

          Welcome to "Bob's Bar" -> "Welcome to &quot;Bob's bar&quot;
        """
        ...
    
    @classmethod
    def substitute_xml(cls, value, make_quoted_attribute: bool = ...):
        """Substitute XML entities for special XML characters.

        :param value: A string to be substituted. The less-than sign
          will become &lt;, the greater-than sign will become &gt;,
          and any ampersands will become &amp;. If you want ampersands
          that appear to be part of an entity definition to be left
          alone, use substitute_xml_containing_entities() instead.

        :param make_quoted_attribute: If True, then the string will be
         quoted, as befits an attribute value.
        """
        ...
    
    @classmethod
    def substitute_xml_containing_entities(cls, value, make_quoted_attribute: bool = ...):
        """Substitute XML entities for special XML characters.

        :param value: A string to be substituted. The less-than sign will
          become &lt;, the greater-than sign will become &gt;, and any
          ampersands that are not part of an entity defition will
          become &amp;.

        :param make_quoted_attribute: If True, then the string will be
         quoted, as befits an attribute value.
        """
        ...
    
    @classmethod
    def substitute_html(cls, s):
        """Replace certain Unicode characters with named HTML entities.

        This differs from data.encode(encoding, 'xmlcharrefreplace')
        in that the goal is to make the result more readable (to those
        with ASCII displays) rather than to recover from
        errors. There's absolutely nothing wrong with a UTF-8 string
        containg a LATIN SMALL LETTER E WITH ACUTE, but replacing that
        character with "&eacute;" will make it more readable to some
        people.
        """
        ...
    


class EncodingDetector:
    """Suggests a number of possible encodings for a bytestring.

    Order of precedence:

    1. Encodings you specifically tell EncodingDetector to try first
    (the override_encodings argument to the constructor).

    2. An encoding declared within the bytestring itself, either in an
    XML declaration (if the bytestring is to be interpreted as an XML
    document), or in a <meta> tag (if the bytestring is to be
    interpreted as an HTML document.)

    3. An encoding detected through textual analysis by chardet,
    cchardet, or a similar external library.

    4. UTF-8.

    5. Windows-1252.
    """
    def __init__(self, markup, override_encodings: Optional[Any] = ..., is_html: bool = ..., exclude_encodings: Optional[Any] = ...):
        self.override_encodings = ...
        self.exclude_encodings = ...
        self.chardet_encoding = ...
        self.is_html = ...
        self.declared_encoding = ...
    
    def _usable(self, encoding, tried):
        ...
    
    @property
    def encodings(self):
        """Yield a number of encodings that might work for this markup."""
        ...
    
    @classmethod
    def strip_byte_order_mark(cls, data):
        """If a byte-order mark is present, strip it and return the encoding it implies."""
        ...
    
    @classmethod
    def find_declared_encoding(cls, markup, is_html: bool = ..., search_entire_document: bool = ...):
        """Given a document, tries to find its declared encoding.

        An XML encoding is declared at the beginning of the document.

        An HTML encoding is declared in a <meta> tag, hopefully near the
        beginning of the document.
        """
        ...
    


class UnicodeDammit:
    """A class for detecting the encoding of a *ML document and
    converting it to a Unicode string. If the source encoding is
    windows-1252, can replace MS smart quotes with their HTML or XML
    equivalents."""
    CHARSET_ALIASES = ...
    ENCODINGS_WITH_SMART_QUOTES = ...
    def __init__(self, markup, override_encodings=..., smart_quotes_to: Optional[Any] = ..., is_html: bool = ..., exclude_encodings=...):
        self.smart_quotes_to = ...
        self.tried_encodings = ...
        self.contains_replacement_characters = ...
        self.is_html = ...
        self.log = ...
        self.detector = ...
        self.markup = ...
        self.unicode_markup = ...
    
    def _sub_ms_char(self, match):
        """Changes a MS smart quote character to an XML or HTML
        entity, or an ASCII character."""
        ...
    
    def _convert_from(self, proposed, errors=...):
        ...
    
    def _to_unicode(self, data, encoding, errors=...):
        '''Given a string and its encoding, decodes the string into Unicode.
        %encoding is a string recognized by encodings.aliases'''
        ...
    
    @property
    def declared_html_encoding(self):
        ...
    
    def find_codec(self, charset):
        ...
    
    def _codec(self, charset):
        ...
    
    MS_CHARS = ...
    MS_CHARS_TO_ASCII = ...
    WINDOWS_1252_TO_UTF8 = ...
    MULTIBYTE_MARKERS_AND_SIZES = ...
    FIRST_MULTIBYTE_MARKER = ...
    LAST_MULTIBYTE_MARKER = ...
    @classmethod
    def detwingle(cls, in_bytes, main_encoding=..., embedded_encoding=...):
        """Fix characters from one encoding embedded in some other encoding.

        Currently the only situation supported is Windows-1252 (or its
        subset ISO-8859-1), embedded in UTF-8.

        The input must be a bytestring. If you've already converted
        the document to Unicode, you're too late.

        The output is a bytestring in which `embedded_encoding`
        characters have been converted to their `main_encoding`
        equivalents.
        """
        ...
    


